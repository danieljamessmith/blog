<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Daniel Smith">
<meta name="dcterms.date" content="2024-02-11">
<meta name="description" content="I introduce the rigorous theory of the Boltzmann Transport Equation, following my undergraduate research project at Warwick Mathematics Institue.">

<title>djs - Portfolio - The Boltzmann Transport Equation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">djs - Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Boltzmann Transport Equation</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Mathematics</div>
    <div class="quarto-category">PDEs</div>
    <div class="quarto-category">Mathematical Physics</div>
    <div class="quarto-category">Boltzmann Equation</div>
  </div>
  </div>

<div>
  <div class="description">
    I introduce the rigorous theory of the Boltzmann Transport Equation, following my undergraduate research project at Warwick Mathematics Institue.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Daniel Smith </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 11, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="the-boltzmann-equation" class="level1">
<h1>THE BOLTZMANN EQUATION</h1>
<section id="the-evolution-equations" class="level2">
<h2 class="anchored" data-anchor-id="the-evolution-equations">The evolution equations</h2>
<p>The <strong>Boltzmann equation</strong> (also known as the <strong>Boltzmann transport equation</strong>) models the behaviour of a gas comprised of a single particle species, sufficiently dilute so that quantum effects are negligible and when all inter-particle interactions are assumed to be elastic binary collisions:</p>
<p><span class="math display">\[\begin{aligned}
\label{eq:1}
    \frac{\partial f}{\partial t} + v\cdot \nabla_{x} f = Q(f,f),\quad x\in X,\: v\in \mathbb{R}^d,\: t\geq0.
\end{aligned}\]</span></p>
<p>Where <span class="math inline">\(f=f(t,x,v)=f_t(x,v)\)</span> is the particle distribution function in phase space and <span class="math inline">\(X \subset \mathbb{R}^d\)</span> <span class="math inline">\((d\geq2)\)</span> is the spatial domain of the gas. If we instead adopt index notation the Boltzmann equation reads</p>
<p><span class="math display">\[\begin{aligned}
    \frac{\partial f}{\partial t} + v_j\frac{\partial f}{\partial x_j} = Q(f,f).
\end{aligned}\]</span></p>
<p>where summation over the term <span class="math inline">\(v_j\frac{\partial f}{\partial x_j}\)</span> is left implicit following Einstein’s summation convention. The operator <span class="math inline">\(Q\)</span> appearing in the above is the <strong>Boltzmann collision operator</strong>, defined by the integral</p>
<p><span class="math display">\[\begin{aligned}
\label{eq:2}
    Q(f,f) = \int_{\mathbb{R}^d\times\mathbb{S}^{d-1}}B(v-v_{*},\sigma)(f'f'_*-ff_*)\,\mathrm{d}\sigma\,\mathrm{d}v_*,
\end{aligned}\]</span></p>
<p>where the function <span class="math inline">\(B\)</span> is the so-called <strong>collision kernel</strong>, whose precise form depends on the nature of the inter-particle interactions being considered, and we have used the standard abbreviations <span class="math inline">\(f'=f(t,x,v')\)</span>, <span class="math inline">\(f_*=f(t,x,v_*)\)</span> and <span class="math inline">\(f'_*=f(t,x,v'_*)\)</span>.</p>
<p>Here we denote by <span class="math inline">\((v',v'_*)\)</span> the precollisional velocities of a pair of particles who have velocities <span class="math inline">\((v,v_*)\)</span> post-collision. By applying the conservation of momentum and energy we can relate the pairs <span class="math inline">\((v',v'_*)\)</span> and <span class="math inline">\((v,v_*)\)</span> via</p>
<p><span class="math display">\[\begin{aligned}
    \begin{cases}
    v' +v'_* = v + v_*\\
    |v'|^2+|v'_*|^2 = |v|^2 +|v_*|^2
    \end{cases}
\end{aligned}\]</span></p>
<p>We parameterise the solution space of this system via the so-called <span class="math inline">\(\mathbf{\sigma}\)</span><strong>-representation</strong>:</p>
<p><span class="math display">\[\begin{aligned}
\begin{cases}
v' = \frac{v+v_*}{2} + \frac{|v-v_*|}{2}\sigma\\
  v_*' = \frac{v+v_*}{2} - \frac{|v-v_*|}{2}\sigma
\end{cases}   
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\sigma \in \mathbb{S}^{d-1}\)</span> is precisely the variable <span class="math inline">\(\sigma\)</span> integrated over in the above integral expression for <span class="math inline">\(Q(f,f)\)</span>. The Boltzmann operator <span class="math inline">\(Q\)</span> admits a clear decomposition into a gain term <span class="math inline">\(Q^+\)</span> and a loss term <span class="math inline">\(Q^-\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
Q(f,f) = Q^+(f,f)-Q^-(f,f),
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(Q^+(f,f)\)</span> ‘counts’ all the collisions which result in a new particle moving with velocity <span class="math inline">\(v\)</span> and <span class="math inline">\(Q^-(f,f)\)</span> ‘counts’ all the collisions in which a particle of velocity <span class="math inline">\(v\)</span> collides with another particle resulting in less particles at velocity <span class="math inline">\(v\)</span>. It is frequently convenient to view the Boltzmann operator as the quadratic form induced by the (non-symmetric) bilinear form</p>
<p><span class="math display">\[\begin{aligned}
    Q(g,f) = \int_{\mathbb{R}^d\times\mathbb{S}^{d-1}}B(v-v_{*},\sigma)(g'f'_*-gf_*)\,\mathrm{d}\sigma\,\mathrm{d}v_*.
\end{aligned}\]</span></p>
<p>When the distribution function <span class="math inline">\(f\)</span> is independent of the spatial variable <span class="math inline">\(x\)</span> the full Boltzmann equation reduces to the <strong>spatially homogeneous Boltzmann equation</strong></p>
<p><span class="math display">\[\begin{aligned}
\label{eq:3}
    \frac{\partial f}{\partial t} = Q(f,f).
\end{aligned}\]</span></p>
<p>If an external force <span class="math inline">\(F = F(x)\)</span> is applied to the system, we instead consider the more general Boltzmann equation with force term</p>
<p><span class="math display">\[\begin{aligned}
    \frac{\partial f}{\partial t} + v\cdot \nabla_{x} f + F\cdot\nabla_{v} f = Q(f,f),
\end{aligned}\]</span></p>
<p>which in index notation reads as</p>
<p><span class="math display">\[\begin{aligned}
    \frac{\partial f}{\partial t} + v_j\frac{\partial f}{\partial x_j} + F_j\frac{\partial f}{\partial v_j} =  Q(f,f).
\end{aligned}\]</span></p>
<p>Given a solution <span class="math inline">\(f\)</span> of the Boltzmann equation (without external force) we can define (in adimensional form) the <strong>local density</strong> <span class="math inline">\(\rho\)</span>, the <strong>local macroscopic velocity</strong> <span class="math inline">\(u\)</span> and the <strong>local temperature</strong> <span class="math inline">\(T\)</span> by</p>
<p><span class="math display">\[\begin{aligned}
\begin{split}
    \rho &amp;= \int_{\mathbb{R}^d}f(t,x,v)\,\text{d}v,\\
    u &amp;= \frac{1}{\rho}\int_{\mathbb{R}^d}f(t,x,v)v\,\text{d}v,\\
    T &amp;= \frac{1}{\rho d}\int_{\mathbb{R}^d}f(t,x,v)|v-u|^2\,\text{d}v.
\end{split}
\end{aligned}\]</span></p>
<p>For a spatially inhomogeneous, equilibrium solution of the Boltzmann equation (i.e.&nbsp;a density <span class="math inline">\(f = f(x,v)\)</span> solving <span class="math inline">\(v\cdot \nabla_{x} f = Q(f,f)\)</span>) we use these quantities to define the <strong>local Maxwellian distribution</strong> <span class="math inline">\(M_{\text{loc}}^f\)</span> associated to <span class="math inline">\(f\)</span> by</p>
<p><span class="math display">\[\begin{aligned}
    M_{\mathrm{loc}}^f(x,v) = \frac{\rho(x)}{(2\pi T(x))^{d/2}}\,\mathrm{exp}\left[-\frac{1}{2T(x)}|v-u(x)|^2\right].
\end{aligned}\]</span></p>
<p>For a spatially homogeneous, equilibrium solution of the Boltzmann equation (i.e.&nbsp;a density <span class="math inline">\(f = f(v)\)</span> solving <span class="math inline">\(Q(f,f)=0\)</span>) <span class="math inline">\(\,\rho,\,u\)</span> and <span class="math inline">\(T\)</span> are constant and correspond to the macroscopic density, velocity and temperature respectively.</p>
<p>Using these quantities we define the (global) <strong>Maxwellian distribution</strong> <span class="math inline">\(M^f\)</span> associated to <span class="math inline">\(f\)</span>, which physically describes the state of <em>thermodynamic equilibrium</em> in which the gas is maximally diffused, by</p>
<p><span class="math display">\[\begin{aligned}
\label{eq:6}
    M^f(v) = \frac{\rho}{(2\pi T)^{d/2}}\,\mathrm{exp}\left[-\frac{1}{2T}|v-u|^2\right].
\end{aligned}\]</span></p>
<p>In the theory of the Boltzmann equation the following question is of central importance:</p>
<p><strong>Under what conditions, and in what sense, do we have <span class="math inline">\(f\longrightarrow M^f\)</span> <em>as</em> <span class="math inline">\(t \longrightarrow \infty\)</span>?</strong></p>
</section>
<section id="boundary-conditions" class="level2">
<h2 class="anchored" data-anchor-id="boundary-conditions">Boundary conditions</h2>
<p>For there to be any hope of our problem being well-posed we need to supplement the Boltzmann equation with boundary conditions, modelling the interactions between the particles and the boundary <span class="math inline">\(\partial X\)</span> of the spatial domain <span class="math inline">\(X\)</span>.</p>
<p>Of course, the only thing restricting the choice of such boundary conditions is our imagination. We briefly discuss some of the most popular and physically relevant choices.</p>
<ul>
<li><p><strong>Specular reflection:</strong> <span class="math display">\[\begin{aligned}
        f(x,R_xv)&amp; = f(x,v),\quad\quad\quad x\in\partial X,\\
        R_xv &amp;= v - 2(v\cdot n(x))n(x),
    \end{aligned}\]</span> where <span class="math inline">\(n(x)\)</span> denotes the unit normal at <span class="math inline">\(x\in\partial X\)</span>. Physically, specular reflection corresponds to the particles elastically colliding with a static, hard wall. Although not particularly accurate, specular reflection is a natural first guess at a boundary condition as it avoids the complex question of modelling the interactions of the particles with the fine microscopic structure of the wall.</p></li>
<li><p><strong>Bounce-back:</strong> <span class="math display">\[\begin{aligned}
        f(x,v) = f(x,-v),\quad x\in\partial X.
        \end{aligned}\]</span> Physically, this condition simply states that particles reflect from the boundary with a velocity opposite to their incident velocity. Although clearly not particularly realistic, it occasionally leads to more physical results than specular reflection as it allows for the transfer of some tangential momentum to the wall, which is not allowed by specular reflection.</p></li>
<li><p><strong>Maxwellian diffusion:</strong> <span class="math display">\[\begin{aligned}
        f(x,v) &amp;= \rho_-(x)M_w(v), \quad v\cdot n(x)&gt;0,\\
        \rho_-(x) &amp;= \int_{v\cdot n&lt;0}f(x,v)|v\cdot n| \,\text{d}v,\\
        M_w(v) &amp;= \frac{1}{(2\pi)^{\frac{d-1}{2}}T_w^{\frac{d+1}{2}}}\,\mathrm{exp}\left[-\frac{|v|^2}{2T_w}\right].
        \end{aligned}\]</span></p></li>
</ul>
</section>
<section id="collision-kernels" class="level2">
<h2 class="anchored" data-anchor-id="collision-kernels">Collision kernels</h2>
<p>The collision kernel <span class="math inline">\(B\)</span> is related to the physical cross section <span class="math inline">\(\Sigma(v-v_*,\sigma)\)</span> by the identity</p>
<p><span class="math display">\[\begin{aligned}
    B = |v-v_*|\Sigma
\end{aligned}\]</span></p>
<p>On physical grounds (<em>Galilean invariance</em>) it is assumed that the collision kernel <span class="math inline">\(B\)</span> depends only on the magnitude of the relative velocity <span class="math inline">\(|v-v_*|\)</span> and the cosine of the deviation angle <span class="math inline">\(\mathrm{cos}\:\theta = \left\langle \frac{v-v_*}{|v-v_*|},\sigma\right\rangle\)</span>. For this reason it is common to abuse notation by writing</p>
<p><span class="math display">\[\begin{aligned}
    B(v-v_*,\sigma) = B(|v-v_*|,\mathrm{cos}\:\theta)
\end{aligned}\]</span></p>
<p>to emphasise the specific forms that collision kernels can take. Maxwell showed that for a given impact parameter <span class="math inline">\(p\geq0\)</span> and relative velocity <span class="math inline">\(z\in\mathbb{R}^3\)</span> the collision kernel is implicitly given by</p>
<p><span class="math display">\[\begin{aligned}
    B(|z|,\mathrm{cos}\:\theta) = \frac{p}{\mathrm{sin}\theta}\frac{\text{d}p}{\text{d}\theta}|z|.
\end{aligned}\]</span></p>
<p>This can be made explicit in the crucially important example of a gas of <strong>hard spheres</strong>, where the gas particles are treated as spheres of fixed radius that interact via elastic collisions (<em>‘billiard balls’</em>). For hard spheres in <span class="math inline">\(d = 3\)</span> the cross section is constant, and thus the collision kernel is given by</p>
<p><span class="math display">\[\begin{aligned}
    B = |v-v_*|.
\end{aligned}\]</span></p>
<p>In the case of particles interacting by an inverse <span class="math inline">\(s\)</span>-power law force the collision kernel factorises as</p>
<p><span class="math display">\[\begin{aligned}
\begin{split}
    B(v-v_*,\cos\theta) &amp;= \Psi(|v-v_*|)\,b(\cos\theta)\\
    &amp;= |v-v_*|^{\gamma}\,b(\cos\theta),
\end{split}
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\Psi(|z|) = |z|^\gamma\)</span> is conventionally called the <strong>kinetic collision kernel</strong>,<br>
<span class="math inline">\(\gamma = (s-5)/(s-1)\)</span> in dimension <span class="math inline">\(d = 3\)</span> and <span class="math inline">\(b(\cos\theta)\)</span> is conventionally called the <strong>angular collision kernel</strong>. The the function <span class="math inline">\(b\)</span> is typically complicated, smooth away from <span class="math inline">\(0\)</span> and is only known implicitly.</p>
<p>Such collision kernels are often further classified by the values of <span class="math inline">\(\gamma\)</span> as follows:</p>
<ul>
<li><p><span class="math inline">\(\gamma &gt; 0\)</span> : <strong>hard potentials</strong></p></li>
<li><p><span class="math inline">\(\gamma &lt; 0\)</span> : <strong>soft potentials</strong></p></li>
<li><p><span class="math inline">\(\gamma = 0\)</span> : <strong>Maxwellian potentials</strong></p></li>
</ul>
<p>The edge case of Maxwellian potentials is interesting as in such cases the collision kernel has no kinetic part and only depends on the cosine of the deviation angle. This occurs for particles interacting via an inverse <span class="math inline">\((2d-1)\)</span>-power law force in <span class="math inline">\(\mathbb{R}^d\)</span> (e.g.&nbsp;a force like <span class="math inline">\(r^{-5}\)</span> in <span class="math inline">\(\mathbb{R}^3\)</span>). Such particles are called <strong>Maxwellian molecules</strong> and should only be considered a theoretical construction.</p>
<p>A crucial assumption frequently made in analytical treatments of the Boltzmann equation is <strong>Grad’s angular cut-off</strong>, which simply assumes that the angular collision kernel <span class="math inline">\(b\)</span> is integrable:</p>
<p><span class="math display">\[\begin{aligned}
\int_{\mathbb{S}^{d-1}}b(k\cdot\sigma)\,\text{d}\sigma = \left|\mathbb{S}^{d-2}\right|\int_0^{\pi}b(\cos\theta)\sin^{d-2}\theta\,\text{d}\theta&lt;\infty.
\end{aligned}\]</span></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>